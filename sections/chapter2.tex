\documentclass[../main.tex]{subfiles}
\begin{document}
  \section{如何描述一门编程语言？}
  \indent 到目前为止，我们都是在以一种非形式化的方式来描述某一门编程语言，
  就像我们在大部分编程书籍上可以看到的那样：

\begin{lstlisting}[language=c]
if (condition) {
  // do something
}
else {
  // do something
}
\end{lstlisting}

  \indent 这固然很好！非形式化的描述直观易懂。
  非常可惜的是：非形式化的描述在我们后续的内容中并不好使。
  为了严格证明我们所构造的类型系统的“正确性”（何为“正确的”类型系统，我们会在之后的章节中解释），
  我们需要使用形式化的方式来描述编程语言，即：用更“数学”的方式表示“这段代码要做什么”。

  \indent 尽管这本小册子将“避重就轻”，为大家省去大量的证明工作，
  了解这些形式化的语言仍然很有必要！
  这些知识可以帮助你理解你所学习和使用的编程语言：例如语言的特性和用法，
  编译器/解释器/运行时环境的原理，等等。\cite{edu}
  因此，我们将花一整章来讨论编程语言的形式化描述。
  为了让这些理论知识更加容易被接受，我们将从小学的语文课开始。

  \subsection{语言的语法}
  \indent 想象一下你回到了你的童年！你正坐在小学的教室里，
  老师正在教你理解一个很长很长的句子。
  在理解句子之前，老师一定会先教给你三样东西：主语、谓语和宾语。
  
  \indent 没错！对于一门自然语言来说，一个简单的句子通常由这三个元素构成。
  无论是汉语、英语或者其他语言：

  \begin{itemize}
    \item 我（主语）打断了（谓语）他的动作（宾语）。
    \item It（主语） is（谓语） a disaster（宾语）!
    \item ……
  \end{itemize}

  \indent 在语文老师（也许还有英语老师）的帮助下，
  我们得到了一个结论：一个句子可以通过主语谓语宾语的拼接组成。
  这就是一门语言的语法（grammar）。
  而上面的“主谓宾结构”构成了一条语法规则：

  $$Sentence ::= (Subject) (verb) (Object)$$

  \indent 这里，我们使用符号$::=$来表示一个语法的推导规则。
  这样的表示形式被称之为巴克斯范式（Backus Normal Form）。\cite{bnfwiki}
  如果我们要判断一堆符号是否可以满足句子的语法，我们有两种方法：

  \begin{itemize}
    \item 推导：我们从$Sentence$符号出发，寻找合适的语法规则，不断推导出新的符号，直到这些符号与我们给出的符号一致，此时我们认为我们的符号串是满足该语法的；
    \item 规约：规约相当于推导的逆运算。我们从已有的符号串出发，寻找合适的语法规则，将符号串合并为一个单一的符号。如果最终我们可以将这些符号合并为$Sentence$，则说明这些符号串是满足该语法的。
  \end{itemize}

  \indent 为了便于理解，这里我们给出一个推导的例子。

  \subsubsection*{例子：使用推导的方式检查英语语法}
    \indent 我们这里就以刚刚的"It is a disaster"为例。
    在开始检查之前，我们需要先将语法规则给出：

    \begin{itemize}
      \item $Sentence ::= Subject\quad verb\quad Object$
      \item $Subject ::= pronoun$
      \item $Object ::= article noun$
      \item $Object ::= pronoun$
    \end{itemize}

    \indent 你可能已经发现了：有些符号的首字母是大写的（如$Subject$）；
    有些符号的首字母是小写的（如$verb$）。
    我们用这种方式区分两类不同的符号：非终结符和终结符。
    非终结符，即字面意义上的“不会中止的符号”。
    非终结符可以出现在语法规则的左侧，并产生一些其他的符号。
    在语法规则中，我们通常用首字母大写的方式表示“这是一个非终结符”。

    \indent 与之相反，非终结符是不可再进行推导的。
    你也许会好奇：冠词（$article$）难道不是可以推导成具体的词汇（a, an和the）吗？
    这里我们省略了一个步骤，叫做词法分析（Lexical Analysis）。
    词法规则可以帮助我们将具体的单词转化为语法分析中所使用的符号。

    \indent 好了！让我们开始推导吧！
    首先我们需要从$Sentence$开始。根据语法规则，我们只能推导出$Subject\quad verb\quad Object$（我们别无选择！）。
    下一步，我们可以再使用规则$Subject ::= pronoun$，从而得到$pronoun\quad verb\quad Object$。
    此时的$pronoun$和$verb$已经是终结符了！我们可以将它们分别与“It”和“is”对应上。

    \indent 下一步对于我们来说有些困难：$Object$符号拥有两种不同的推导规则。
    我们必须在二者之间做出抉择。通过对句子的观察，我们发现后面的部分出现了冠词“a”。
    这下就非常明了了！我们的宾语是带有一个冠词的。因此，我们选择规则 $Object ::= article noun$而不是$Object ::= pronoun$。
    最终，我们将$article$与“a”，$noun$与“disaster”对应，证实了这个句子是符合语法的。

    \indent 你也可以尝试一下逆向的规约。这会稍有难度。
    \newline
  
  \indent 编程语言作为另一类“语言”（另类在我们用它和计算机沟通而不是和人沟通），
  是否可以用类似的方法来理解呢？答案是肯定的。
  在计算机科学中，编程语言的语法（syntax）\footnote[1]{注：这里的“语法”与自然语言的语法仍有很大的差别。自然语言的语法包括句法、词汇形态学和音系学\cite{grammar}，而编程语言中的语法其实仅指句法。因此这里的英文是syntax而不是grammar。尽管自然语言课程上我们所学的也是句法，但基于大量老师喜欢使用grammar来表示”这堂课是语法课“，我们在上文也依旧沿用grammar一词。}
  包含一系列的语法规则，
  这些规则规定了符号如何进行排列，从而得到有意义的计算机程序语句或表达式。\cite{syntaxwiki}

  \indent 本章开头给了一个C语言中if语句的非形式化描述。
  现在，我们用一个更形式化的方式来表示它：

  $$
  Sentence ::= if(Expr)\{ Sentence^*\} else\{Sentence^*\}
  $$

  \indent 这种表示形式被称为巴克斯范式（Backus Normal Form）。
  这种语法被称为上下文无关语法。\cite{bnfwiki}
  之所以被叫做“上下文无关”，是因为语法规则左侧的$Sentence$前后（上文和下文）均没有其他的符号，
  即它不关心自己前后会出现什么样的内容，并始终通过这个规则来产生具体的句子。\cite{cfgwiki}
  对于自然语言来说，这样的语法可能并不足以表达，不过对于编程语言来说，这样简单的语法刚刚好。

  \indent 上面的语法规则中出现了一个$Expr$，它表示一个表达式。
  显然，表达式也应该有一个自己的语法规则，例如两个表达式相加或者相减应该也是一个表达式。
  因此，我们可以这样写：

  $$Expr ::= num\,|\,Expr + Expr\,|\,Expr - Expr$$

  \indent 我想你应该已经开始头疼了。出现了大量的符号，而我们还没有做任何的解释！
  不过值得庆幸的是，这两个例子已经覆盖了几乎所有你需要知道的上下文无关文法和巴克斯范式有关的知识了。
  现在我们就开始进行逐一解释\cite{bnfwiki} \cite{cfgwiki}：

  \begin{itemize}
    \item 巴克斯范式使用 $::=$ 来描述语法规则。$A ::= \beta$所表示的含义是：符号$A$所可以推导出的内容是$B$，即你可以将句子中的$A$替换为$\beta$；
    \item 符号$A$必须“可以继续推导”，例如上面的$Sentence$或者$Expr$。这样可以继续推导的符号我们称之为非终结符；
    \item 反之，像$if$这样的关键字或者$num$这样的数字字面量，他们本身不可以再进行任何的推导，这样的符号称之为终结符\footnote[1]{你可能会觉得奇怪，$num$明明还可以推导出$1, 2, \dots$这些数字，为什么它是终结符？事实上，$num = 1, 2, \dots$这个过程在计算机科学中被称作词法分析，是一个先于语法分析的过程。因此在语法中无论是怎么样的数字，我们都认为它们是$num$。}；
    \item 我们使用首字母大写来表示一个符号是非终结符，用首字母小写来表示终结符，用希腊字母来表示任意的符号串（只有终结符、只有非终结符或者二者兼有）
    \item $\alpha \beta$表示将两个符号串拼接在一起
    \item $\alpha^*$表示$\alpha$可以在这个位置出现任意次（0次或者多次）
    \item $\alpha\,|\,\beta$表示这里既可以推导出$\alpha$，也可以推导出$\beta$，但不能是二者同时；
    \item 当一个符号串可以由某个起始的非终结符（一般写作$S$）根据语法规则推导得到，我们称这个符号串是满足该语法的。
  \end{itemize}

  \indent 事实上，所有编程语言都会有一套这样的语法规则。
  编译器/解释器会根据这套规则分析给定的代码是否满足要求，无法满足要求的代码会被拒绝编译/执行。
  例如$Expr$，我们可以根据语法规则$Expr ::= Expr + Expr$得到$Expr + Expr$。
  再根据$Expr ::= num$，从而得到$num + num$。因此，类似于$5 + 6$的代码是一个合法的表达式。
  反之，你无法通过这一系列的规则得到$5\,6+++$这样的代码，因此编译器/解释器会向你提示代码出错。

  \indent 有关于语法分析的内容还有很多，例如递归消除，语法歧义等等。
  出于简化的目的，我们在这里不再阐述这些内容。如果你对此感兴趣，可以参考《编译原理（Compilers: Principles, Techniques, and Tools）》这本书中的内容。

  \subsection{如果只有语法的话……}
  % TODO

  \subsection{操作语义（Operational Semantics）}
  % TODO

  \subsection{实例：一个只有整数加减法的语言}
  % TODO

  \begin{thebibliography}{5}
    \bibitem{edu} 知乎专栏. 2018. 浅谈国内高校编程语言教育. [online] Available at: <\url{https://zhuanlan.zhihu.com/p/43914842}> [Accessed 2 October 2022].
    \bibitem{syntaxwiki} En.wikipedia.org. 2022. Syntax (programming languages) - Wikipedia. [online] Available at: <\url{https://en.wikipedia.org/wiki/Syntax_(programming_languages)}> [Accessed 2 October 2022].
    \bibitem{grammar} 王, 力., 2015. 中国语法理论. 中华书局, p.6.
    \bibitem{bnfwiki} Zh.wikipedia.org. 2020. 巴科斯范式 - 维基百科，自由的百科全书. [online] Available at: <\url{https://zh.wikipedia.org/zh-hans/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F}> [Accessed 2 October 2022]. 
    \bibitem{cfgwiki} Zh.wikipedia.org. 2021. 上下文无关文法 - 维基百科，自由的百科全书. [online] Available at: <\url{https://zh.wikipedia.org/zh-hans/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95}> [Accessed 2 October 2022].
  \end{thebibliography}
\end{document}