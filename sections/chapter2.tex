\documentclass[../main.tex]{subfiles}
\begin{document}
  \section{如何描述一门编程语言？}
  \indent 到目前为止，我们都是在以一种非形式化的方式来描述某一门编程语言，
  就像我们在大部分编程书籍上可以看到的那样：

\begin{lstlisting}[language=c]
if (condition) {
  // do something
}
else {
  // do something
}
\end{lstlisting}

  \indent 这固然很好！非形式化的描述直观易懂。
  非常可惜的是：非形式化的描述在我们后续的内容中并不好使。
  为了严格证明我们所构造的类型系统的“正确性”（何为“正确的”类型系统，我们会在之后的章节中解释），
  我们需要使用形式化的方式来描述编程语言，即：用更“数学”的方式表示“这段代码要做什么”。

  \indent 尽管这本小册子将“避重就轻”，为大家省去大量的证明工作，
  了解这些形式化的语言仍然很有必要！
  这些知识可以帮助你理解你所学习和使用的编程语言：例如语言的特性和用法，
  编译器/解释器/运行时环境的原理，等等。\cite{edu}
  因此，我们将花一整章来讨论编程语言的形式化描述。
  为了让这些理论知识更加容易被接受，我们将从小学的语文课开始。

  \subsection{语言的语法}
  \indent 想象一下你回到了你的童年！你正坐在小学的教室里，
  老师正在教你理解一个很长很长的句子。
  在理解句子之前，老师一定会先教给你三样东西：主语、谓语和宾语。
  
  \indent 没错！对于一门自然语言来说，一个简单的句子通常由这三个元素构成。
  无论是汉语、英语或者其他语言：

  \begin{itemize}
    \item 我（主语）打断了（谓语）他的动作（宾语）。
    \item It（主语） is（谓语） a disaster（宾语）!
    \item ……
  \end{itemize}

  \indent 在语文老师（也许还有英语老师）的帮助下，
  我们得到了一个结论：一个句子可以通过主语谓语宾语的拼接组成。
  这就是一门语言的语法（grammar）。
  而上面的“主谓宾结构”构成了一条语法规则：

  $$Sentence ::= (Subject) (verb) (Object)$$

  \indent 这里，我们使用符号$::=$来表示一个语法的推导规则。
  这样的表示形式被称之为巴克斯范式（Backus Normal Form）。\cite{bnfwiki}
  如果我们要判断一堆符号是否可以满足句子的语法，我们有两种方法：

  \begin{itemize}
    \item 推导：我们从$Sentence$符号出发，寻找合适的语法规则，不断推导出新的符号，直到这些符号与我们给出的符号一致，此时我们认为我们的符号串是满足该语法的；
    \item 规约：规约相当于推导的逆运算。我们从已有的符号串出发，寻找合适的语法规则，将符号串合并为一个单一的符号。如果最终我们可以将这些符号合并为$Sentence$，则说明这些符号串是满足该语法的。
  \end{itemize}

  \indent 为了便于理解，这里我们给出一个推导的例子。

  \subsubsection*{例子：使用推导的方式检查英语语法}
    \indent 我们这里就以刚刚的"It is a disaster"为例。
    在开始检查之前，我们需要先将语法规则给出：

    \begin{itemize}
      \item $Sentence ::= Subject\quad verb\quad Object$
      \item $Subject ::= pronoun$
      \item $Object ::= article noun$
      \item $Object ::= pronoun$
    \end{itemize}

    \indent 你可能已经发现了：有些符号的首字母是大写的（如$Subject$）；
    有些符号的首字母是小写的（如$verb$）。
    我们用这种方式区分两类不同的符号：非终结符和终结符。
    非终结符，即字面意义上的“不会中止的符号”。
    非终结符可以出现在语法规则的左侧，并产生一些其他的符号。
    在语法规则中，我们通常用首字母大写的方式表示“这是一个非终结符”。

    \indent 与之相反，非终结符是不可再进行推导的。
    你也许会好奇：冠词（$article$）难道不是可以推导成具体的词汇（a, an和the）吗？
    这里我们省略了一个步骤，叫做词法分析（Lexical Analysis）。
    词法规则可以帮助我们将具体的单词转化为语法分析中所使用的符号。

    \indent 好了！让我们开始推导吧！
    首先我们需要从$Sentence$开始。根据语法规则，我们只能推导出$Subject\quad verb\quad Object$（我们别无选择！）。
    下一步，我们可以再使用规则$Subject ::= pronoun$，从而得到$pronoun\quad verb\quad Object$。
    此时的$pronoun$和$verb$已经是终结符了！我们可以将它们分别与“It”和“is”对应上。

    \indent 下一步对于我们来说有些困难：$Object$符号拥有两种不同的推导规则。
    我们必须在二者之间做出抉择。通过对句子的观察，我们发现后面的部分出现了冠词“a”。
    这下就非常明了了！我们的宾语是带有一个冠词的。因此，我们选择规则 $Object ::= article noun$而不是$Object ::= pronoun$。
    最终，我们将$article$与“a”，$noun$与“disaster”对应，证实了这个句子是符合语法的。

    \indent 在后文中，对于这样包含多个分支的语法规则，我们将写成以下的形式：

    $$Object ::= article noun\,|\,pronoun$$

    \indent 符号$|$表示“或”的意思。这表示左侧的非终结符可以推导为多种不同的形式（但不能是二者同时）。
    这样的表示方式更加紧凑，在计算机科学的文献或者工程项目中大量使用。

    \indent 你也可以尝试一下逆向的规约。这会稍有难度。
    \newline
  
  \indent 编程语言作为另一类“语言”（另类在我们用它和计算机沟通而不是和人沟通），
  我们也可以用类似的方法来表示。
  在计算机科学中，编程语言的语法（syntax）\footnote[1]{注：这里的“语法”与自然语言的语法仍有很大的差别。自然语言的语法包括句法、词汇形态学和音系学\cite{grammar}，而编程语言中的语法其实仅指句法。因此这里的英文是syntax而不是grammar。尽管自然语言课程上我们所学的也是句法，但基于大量老师喜欢使用grammar来表示”这堂课是语法课“，我们在上文也依旧沿用grammar一词。}
  包含一系列的语法规则，
  这些规则规定了符号如何进行排列，从而得到有意义的计算机程序语句或表达式。\cite{syntaxwiki}
  
  \indent 对于自然语言来说，这样的语法规则其实很难把整个语言完全描述清楚。
  巴克斯范式描述的语法通常被称为上下文无关语法。
  之所以被叫做“上下文无关”，是因为语法规则左侧的非终结符前后（上文和下文）均没有其他的符号，
  即它不关心自己前后会出现什么样的内容，并始终通过这个规则来产生具体的句子。
  自然语言很难做到“上下文无关”，但是代码通常是可以的：绝大多数的编程语言都可以使用上下文无关语法来描述。\cite{cfgwiki}

  \indent 本章的目的是讨论“如何形式化地描述一门语言”。
  现在，我们就拿开头的C语言代码开刀：

  $$
  Statement ::= if(Expr)\{ Statement^*\} else\{Statement^*\}
  $$

  \indent 这里我们又引入了一个新的符号${}^*$。
  语法规则$\alpha^*$（这里我们用希腊字母$\alpha$代指任意的符号串：既可以包含终结符，也可以包含非终结符）的含义是：
  在推导中，符号串$\alpha$可以出现任意次（0次，1次，甚至更多次）。

  \indent 至此，你已经学会了如何描述一门语言的语法了！
  你可以在你喜欢的语言上做一些尝试。这里我们给出一些简单的例子：

  \begin{itemize}
    \item Scala语言中的if表达式：$If ::= if(Expr)\,Expr\,else\,Expr$
    \item Java语言中的import：$Impt ::= import\,pkgname\,(dot\,pkgname)^*$\footnote[1]{这里的括号并不是语法符号，而是表示将$.$和$pkgname$视作一个整体，即运算优先级的调整}
    \item $\dots$
  \end{itemize}

  \subsubsection*{补充：其他的符号}
    \indent 我们已经见到了$|$和${}^*$这样的符号。
    事实上，还有一些其他的符号可以用于语法描述

    \begin{itemize}
      \item $\epsilon$是一个特殊的希腊字符，它被用来表示空白。$A ::= \epsilon$表示符号$A$会产生一个空串，我们可以将$bAb$推导为$bb$；
      \item $\alpha+$：这里的加号表示$\alpha$可以出现任意非零次（1次，2次甚至更多，但不能不出现）。这与$\alpha\alpha*$是等价的；
      \item $\alpha?$：这里的问号表示$\alpha$只能出现一次或者零次。它与$\alpha\,|\,\epsilon$是等价的。
    \end{itemize}

    \indent 

  \indent 有关于语法分析的内容还有很多，例如递归消除，语法歧义等等。
  如何将这些推导（规约）的过程应用到编译器上也是一个非常复杂的话题。
  出于简化的目的，我们在这里不再阐述这些内容。如果你对此感兴趣，可以参考《编译原理（Compilers: Principles, Techniques, and Tools）》这本书中的内容。

  \subsection{如果只有语法的话……}
  \indent 我们已经知道如何描述一门语言的语法了！
  现在我们可以开始讨论类型系统了吗？

  \indent 很遗憾，还不能——因为语法不是一门语言的全部。

  \indent 回到自然语言的例子上来，
  让我们讨论一个非常现实的问题：满足语法的句子就是好的句子吗？
  作为参考，以下是一些“满足语法规则”的句子：

  \begin{itemize}
    \item 我想喝咖啡。
    \item 你不应该这样做。
    \item 豆腐正在舔奶牛。
  \end{itemize}

  \indent 这些句子看起来都不错……除了最后一个。\footnote[1]{为此，请允许我在这里假定：豆腐不是一个人或者什么宠物的名字，它只是一块普通的，没有变异的，可以食用的豆腐！}
  “舔”这个动作，它的发出者至少应该具有舌头或者类似的结构，而一块豆腐甚至连嘴都没有！\footnote[2]{虽然我们常说“豆腐嘴刀子心”，但这和豆腐有没有嘴没有任何关系！}

  \indent 我们发现了：只有语法的话，我们的语言系统将会陷入混乱！
  为了能够完全理解语言所要表达的东西，我们还需要另一个工具：语义（semantics）。
  在计算机科学中，语义是对一个形式语言系统的解释。\cite{semwiki}
  直观一点来说：语义解释了一段符合语法的程序应该如何运行，最终得到用户期望的输出。

  \indent 有三种方法可以形式化地描述语义：\cite{tapl}

  \begin{itemize}
    \item 操作语义（Operational Semantics）：在操作语义中，我们将程序想象为一个状态机。语法中的项（也就是我们先前提到的符号，这里也称作term）就是状态机中的状态，每一次对项的变换等同于状态的转换；
    \item 指称语义（Denotational Semantics）：指称语义比操作语义更加抽象。指称语义往往以数学对象为基础，研究如何将语法项映射到对应的语义定义域（semantic domains）上；
    \item 公理语义（Axiomatic Semantics）：公理语义将各种定律视作语言的定义，而语法项的运算则是这些定律的证明过程。
  \end{itemize}

  \indent 其中，操作语义凭借着其更加简洁和灵活的优势，
  在程序的形式化描述中被广泛应用。\cite{tapl}
  我们在下一节中也将更详细地介绍操作语义。

  \subsection{操作语义（Operational Semantics）}
  % TODO

  \subsection{实例：一个只有整数加减法的语言}
  % TODO

  \begin{thebibliography}{7}
    \bibitem{edu} 知乎专栏. 2018. 浅谈国内高校编程语言教育. [online] Available at: <\url{https://zhuanlan.zhihu.com/p/43914842}> [Accessed 2 October 2022].
    \bibitem{syntaxwiki} En.wikipedia.org. 2022. Syntax (programming languages) - Wikipedia. [online] Available at: <\url{https://en.wikipedia.org/wiki/Syntax_(programming_languages)}> [Accessed 2 October 2022].
    \bibitem{grammar} 王, 力., 2015. 中国语法理论. 中华书局, p.6.
    \bibitem{bnfwiki} Zh.wikipedia.org. 2020. 巴科斯范式 - 维基百科，自由的百科全书. [online] Available at: <\url{https://zh.wikipedia.org/zh-hans/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F}> [Accessed 2 October 2022]. 
    \bibitem{cfgwiki} Zh.wikipedia.org. 2021. 上下文无关文法 - 维基百科，自由的百科全书. [online] Available at: <\url{https://zh.wikipedia.org/zh-hans/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95}> [Accessed 2 October 2022].
    \bibitem{semwiki} Zh.wikipedia.org. 2022. 语义学 - 维基百科，自由的百科全书. [online] Available at: <\url{https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E4%B9%89%E5%AD%A6}> [Accessed 5 October 2022].
    \bibitem{tapl} Pierce, B., 2002. Types and Programming Languages. London, England: The MIT Press, pp.32-34.
  \end{thebibliography}
\end{document}